#!/usr/bin/env python3
# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# This script was generated by Gemini 3 Pro Preview.

import argparse
import os
import re
import subprocess
import sys
from collections import defaultdict
from dataclasses import dataclass
from pathlib import Path
from typing import Optional

# --- Constants & Mappings ---

DEFAULT_TARGET_REF = "origin/main"

DEFAULT_PROJECT_COMMIT_URL = "<BASE URL>/ml-flashpoint"

TAG_VERSION_PATTERN = r"^v\d+\.\d+\.\d+$"

EMOJI_MAPPING = {
    "feat": ":trophy:",
    "fix": ":white_check_mark:",
    "chore": ":nut_and_bolt:",
    "refactor": ":recycle:",
    "revert": ":leftwards_arrow_with_hook:",
    "test": ":mag:",
    "docs": ":notebook_with_decorative_cover:",
    "perf": ":clock1:",
    "style": ":art:",
    "build": ":twisted_rightwards_arrows:",
    "ci": ":arrows_clockwise:",
    "other": "¯\\(ツ)/¯",
}

TYPE_FULL_NAMES = {
    "feat": "Features",
    "fix": "Bug Fixes",
    "chore": "Chores",
    "refactor": "Refactoring",
    "revert": "Reverts",
    "test": "Tests",
    "docs": "Documentation",
    "perf": "Performance",
    "style": "Styles",
    "build": "Build",
    "ci": "CI",
    "other": "Other",
}


@dataclass
class Commit:
    hash: str
    author: str
    date: str
    type: str
    scope: Optional[str]
    subject: str
    original_subject: str


# --- Helper Functions ---


def run_command(command):
    """Runs a shell command and returns the output as a string."""
    try:
        print(f"Running command: {command}")
        result = subprocess.run(
            command, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"Error running command: {command}")
        print(e.stderr)
        sys.exit(1)


def get_input(prompt, default=None):
    """Gets input from the user with an optional default."""
    if default:
        full_prompt = f"{prompt} [Press Enter for default: {default}]: "
    else:
        full_prompt = f"{prompt}: "

    val = input(full_prompt).strip()
    return val if val else default


def get_latest_tag():
    """Gets the latest git tag matching vX.Y.Z."""
    try:
        # Match tags like v1.0.0, v0.1.0 etc.
        # We use v[0-9]*.[0-9]*.[0-9]* as a glob pattern for git describe --match
        # using subprocess directly to suppress error output if no tag found
        result = subprocess.run(
            ["git", "describe", "--tags", "--abbrev=0", "--match", "v[0-9]*.[0-9]*.[0-9]*"],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return None


def get_commits(start_ref, end_ref):
    """Gets commits between two references."""
    # Format: hash|author|date|subject
    cmd = f'git log {start_ref}...{end_ref} --pretty=format:"%H|%an|%cs|%s"'
    if not start_ref:
        cmd = f'git log {end_ref} --pretty=format:"%H|%an|%cs|%s"'

    try:
        output = run_command(cmd)
        if not output:
            return []
        return output.split("\n")
    except SystemExit:
        return []


def parse_commit(line):
    """Parses a commit line into type, scope, subject, hash."""
    # line is "hash|author|date|subject"
    parts = line.split("|", 3)
    if len(parts) < 4:
        return None

    commit_hash = parts[0]
    author = parts[1]
    date = parts[2]
    full_subject = parts[3]

    # Regex for conventional commits: type(scope): subject or type: subject
    # We also want to capture the whole prefix for replacement
    match = re.match(r"^(\w+)(?:\(([^)]+)\))?:\s*(.+)$", full_subject)

    if match:
        msg_type = match.group(1)
        scope = match.group(2)
        subject = match.group(3)
    else:
        msg_type = "other"
        scope = None
        subject = full_subject

    return Commit(
        hash=commit_hash,
        author=author,
        date=date,
        type=msg_type,
        scope=scope,
        subject=subject,
        original_subject=full_subject,
    )


def format_commit_line(commit, project_url, group_by):
    """Formats the commit line based on the grouping strategy."""
    h = commit.hash
    short_h = h[:7]
    link = f"({project_url}/+/{h})" if project_url else ""

    msg_type = commit.type
    scope = commit.scope
    subject = commit.subject
    emoji = EMOJI_MAPPING.get(msg_type, "")

    # Grouping by TYPE:
    # Format: * scope: subject  OR  * subject
    if group_by == "type":
        if scope:
            line_content = f"{scope}: {subject}"
        else:
            line_content = f"{subject}"
        # If it's the "Other" group, we might want to keep the original subject if parsing failed
        if msg_type == "other":
            line_content = commit.original_subject

    # Grouping by SCOPE:
    # Format: * :emoji: type: subject
    elif group_by == "scope":
        if msg_type == "other":
            line_content = commit.original_subject
        else:
            # Add emoji + type
            prefix = f"{emoji} {msg_type}:" if emoji else f"{msg_type}:"
            line_content = f"{prefix} {subject}"

    return f"* [({short_h})]{link} {line_content}"


def generate_grouped_notes(commits, project_url, group_by, start_ref, end_ref):
    """Groups and formats the release notes, returning them as a string."""
    groups = defaultdict(list)

    for line in commits:
        commit = parse_commit(line)
        if not commit:
            continue

        key = "other"
        if group_by == "type":
            key = commit.type if commit.type in TYPE_FULL_NAMES else "other"
        elif group_by == "scope":
            key = commit.scope if commit.scope else "Other"

        groups[key].append(commit)

    # Sort keys:
    # For types: specific order is usually nice (Feat, Fix, etc.)
    # For scopes: alphabetical

    if group_by == "type":
        # Define a priority order
        priority = [
            "feat",
            "fix",
            "perf",
            "refactor",
            "style",
            "test",
            "docs",
            "build",
            "ci",
            "chore",
            "revert",
            "other",
        ]
        # Filter keys that exist in groups
        existing_keys = set(groups.keys())
        sorted_keys = [k for k in priority if k in existing_keys]
        # Add any remaining keys not in priority (unlikely given logic above but good for safety)
        for k in existing_keys:
            if k not in sorted_keys:
                sorted_keys.append(k)
    else:
        sorted_keys = sorted(groups.keys())

    output = []
    start_disp = start_ref if start_ref else "BEGINNING"
    output.append(f"_Release Notes: {start_disp} -> {end_ref}_\n")
    output.append("-----")
    for key in sorted_keys:
        commit_list = groups[key]

        # Header formatting
        if group_by == "type":
            emoji = EMOJI_MAPPING.get(key, "")
            full_name = TYPE_FULL_NAMES.get(key, key.capitalize())
            header = f"### {emoji} {full_name}".strip()
        else:
            header = f"### {key}"

        output.append(f"\n{header}")
        for commit in commit_list:
            output.append(format_commit_line(commit, project_url, group_by))

    output.append("\n-----")
    cmd_line = " ".join(sys.argv)
    output.append(f"\n_Generated with: `{cmd_line}`_")
    return "\n".join(output)


def main():
    parser = argparse.ArgumentParser(description="Generate release notes and optionally create a git tag.")
    parser.add_argument(
        "--group-by",
        choices=["type", "scope"],
        default="type",
        help="Group commits by 'type' or 'scope'. Defaults to 'type'.",
    )
    parser.add_argument(
        "--from-ref",
        help="The revision to start from (exclusive). Defaults to the latest _release_ tag, "
        "or beginning of time if there is none found.",
    )
    parser.add_argument(
        "--to-ref",
        help=f"The revision to end at (inclusive). Defaults to '{DEFAULT_TARGET_REF}'.",
    )
    args = parser.parse_args()

    print("Fetching origin to ensure we have the latest info...")
    run_command("git fetch origin")

    # 1. Determine target ref
    if args.to_ref:
        target_ref = args.to_ref
        print(f"Using target ref: {target_ref}")
    else:
        target_ref = get_input("Enter the target commit/branch (must be remote)", default=DEFAULT_TARGET_REF)

    # Verify target commit exists
    try:
        # Resolve to specific commit hash to ensure consistency
        resolved_target_commit = run_command(f"git rev-parse --verify {target_ref}")
        print(f"Target commit resolved to: {resolved_target_commit}")
    except SystemExit:
        print(f"Error: Commit '{target_ref}' does not exist or is not reachable.")
        sys.exit(1)

    # 2. Determine start ref
    latest_tag_found = get_latest_tag()
    if args.from_ref:
        start_ref = args.from_ref
    else:
        start_ref = latest_tag_found

    print(
        f"\nGenerating release notes from {start_ref if start_ref else 'BEGINNING'} to "
        f"{target_ref} ({resolved_target_commit})...\n"
    )

    # 3. Generate notes
    commits = get_commits(start_ref, resolved_target_commit)

    # Try to determine project URL from environment or git remote
    project_url = os.environ.get("CI_PROJECT_URL", "")
    if not project_url:
        # Fallback to default if not set
        project_url = DEFAULT_PROJECT_COMMIT_URL

        # try to guess from remote to override if it's a public repo
        try:
            remote_url = run_command("git remote get-url origin")
            if "github.com" in remote_url or "gitlab.com" in remote_url:
                project_url = remote_url.replace(".git", "")
        except RuntimeError:
            pass

    notes = generate_grouped_notes(commits, project_url, args.group_by, start_ref, resolved_target_commit)

    output_file = "tmp_release_notes.md"
    with open(output_file, "w") as f:
        f.write(notes)
    print(notes)
    print(f"\nRelease notes also written to: {Path(output_file).resolve()}")
    print("Make sure to add them to docs/changelog.md.")

    # 4. Ask to create tag
    # TODO: Currently pushing git tags is banned by Gerrit, we can re-enable this when we migrate to GitHub
    # print(f"\nLatest previous release tag was: {latest_tag_found}")
    # confirm = get_input("Do you want to create a release tag? (y/N)", "N")
    # if confirm.lower() == "y":
    #     tag_version = get_input(f"Enter the new tag version (e.g. 'v1.2.3'). Latest tag was '{latest_tag_found}'")
    #     if not tag_version:
    #         print("Tag version is required to create a tag.")
    #         sys.exit(1)
    #
    #     if not re.match(TAG_VERSION_PATTERN, tag_version):
    #         print(f"Error: Tag version must match format 'vX.Y.Z' (e.g. v1.2.3). Got: {tag_version}")
    #         sys.exit(1)
    #
    #     run_command(f"git tag -a {tag_version} {target_commit} -m 'Release {tag_version}'")
    #     print(f"Tag '{tag_version}' created successfully.")
    #     print("Don't forget to push it: git push origin --tags")
    #     print("Then upload the release notes above.")
    # else:
    #     print("Tag creation aborted.")


if __name__ == "__main__":
    main()
